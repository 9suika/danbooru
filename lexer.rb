
# line 1 "lexer.rl"
require 'cgi'
require 'uri'
require 'stringio'
# require 'minitest/autorun'

class ParseError < RuntimeError
end


# line 492 "lexer.rl"


class DTextRagel
  attr_reader :stack, :dstack, :data, :eof, :flags

  def initialize(string, flags = {})
    @output = StringIO.new
    @stack = []
    @dstack = []
    @data = string + "\0"
    @eof = @data.size
    @flags = flags

    
# line 28 "lexer.rb"
class << self
	attr_accessor :_dtext_actions
	private :_dtext_actions, :_dtext_actions=
end
self._dtext_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 6, 1, 7, 1, 
	8, 1, 13, 1, 14, 1, 15, 1, 
	18, 1, 19, 1, 20, 1, 21, 1, 
	22, 1, 23, 1, 24, 1, 25, 1, 
	26, 1, 27, 1, 28, 1, 29, 1, 
	30, 1, 31, 1, 32, 1, 33, 1, 
	34, 1, 35, 1, 36, 1, 37, 1, 
	38, 1, 39, 1, 40, 1, 53, 1, 
	55, 1, 56, 1, 57, 1, 58, 1, 
	59, 1, 60, 1, 61, 1, 62, 1, 
	63, 1, 64, 1, 65, 1, 66, 1, 
	67, 1, 68, 1, 69, 1, 70, 1, 
	71, 1, 72, 1, 73, 1, 74, 1, 
	75, 1, 76, 1, 77, 1, 78, 1, 
	79, 1, 80, 1, 81, 1, 82, 1, 
	85, 1, 86, 1, 87, 1, 88, 1, 
	89, 1, 90, 1, 92, 1, 93, 1, 
	94, 1, 96, 1, 97, 1, 98, 1, 
	99, 2, 1, 41, 2, 1, 42, 2, 
	1, 43, 2, 1, 45, 2, 1, 46, 
	2, 1, 47, 2, 1, 48, 2, 1, 
	49, 2, 1, 50, 2, 1, 54, 2, 
	1, 60, 2, 1, 91, 2, 3, 16, 
	2, 3, 44, 2, 3, 51, 2, 3, 
	52, 2, 3, 95, 2, 8, 0, 2, 
	8, 9, 2, 8, 10, 2, 8, 11, 
	2, 8, 12, 2, 8, 84, 3, 1, 
	5, 17, 3, 8, 2, 83
]

class << self
	attr_accessor :_dtext_trans_keys
	private :_dtext_trans_keys, :_dtext_trans_keys=
end
self._dtext_trans_keys = [
	111, 111, 100, 100, 101, 101, 
	93, 93, 120, 120, 112, 
	112, 97, 97, 110, 110, 
	100, 100, 61, 93, 93, 93, 
	93, 93, 111, 111, 100, 
	100, 116, 116, 101, 101, 
	120, 120, 116, 116, 93, 93, 
	117, 117, 111, 111, 116, 
	116, 101, 101, 93, 93, 
	112, 112, 111, 111, 105, 105, 
	108, 108, 101, 101, 114, 
	114, 93, 93, 97, 97, 
	98, 98, 108, 108, 101, 101, 
	93, 93, 46, 46, 9, 
	126, 34, 34, 58, 58, 
	91, 104, 104, 104, 116, 116, 
	116, 116, 112, 112, 58, 
	115, 47, 47, 47, 47, 
	33, 126, 33, 126, 58, 58, 
	116, 116, 116, 116, 112, 
	112, 58, 115, 47, 47, 
	47, 47, 33, 126, 58, 58, 
	98, 117, 93, 93, 120, 
	120, 112, 112, 97, 97, 
	110, 110, 100, 100, 93, 93, 
	93, 93, 117, 117, 111, 
	111, 116, 116, 101, 101, 
	93, 93, 93, 112, 111, 111, 
	105, 105, 108, 108, 101, 
	101, 114, 114, 93, 93, 
	100, 110, 93, 93, 93, 93, 
	93, 93, 93, 124, 93, 
	124, 93, 93, 93, 93, 
	93, 93, 93, 93, 93, 93, 
	120, 120, 112, 112, 97, 
	97, 110, 110, 100, 100, 
	93, 93, 93, 93, 111, 111, 
	100, 100, 116, 116, 101, 
	101, 120, 120, 116, 116, 
	93, 93, 117, 117, 111, 111, 
	116, 116, 101, 101, 93, 
	93, 93, 112, 111, 111, 
	105, 105, 108, 108, 101, 101, 
	114, 114, 93, 93, 110, 
	110, 93, 93, 93, 93, 
	116, 116, 105, 105, 115, 115, 
	116, 116, 32, 32, 35, 
	35, 48, 57, 109, 109, 
	109, 109, 101, 101, 110, 110, 
	116, 116, 32, 32, 35, 
	35, 48, 57, 114, 114, 
	117, 117, 109, 109, 32, 32, 
	35, 35, 48, 57, 116, 
	116, 112, 112, 58, 115, 
	47, 47, 47, 47, 33, 126, 
	58, 58, 115, 115, 117, 
	117, 101, 101, 32, 32, 
	35, 35, 48, 57, 120, 120, 
	105, 105, 118, 118, 32, 
	32, 35, 35, 48, 57, 
	112, 112, 48, 57, 111, 115, 
	108, 108, 32, 32, 35, 
	35, 48, 57, 116, 116, 
	32, 32, 35, 35, 48, 57, 
	112, 112, 105, 105, 99, 
	99, 32, 32, 35, 35, 
	48, 57, 112, 112, 48, 57, 
	101, 101, 114, 114, 32, 
	32, 35, 35, 48, 57, 
	125, 125, 125, 125, 125, 125, 
	99, 99, 111, 111, 100, 
	100, 101, 101, 93, 93, 
	110, 110, 111, 111, 100, 100, 
	116, 116, 101, 101, 120, 
	120, 116, 116, 93, 93, 
	116, 116, 97, 114, 98, 98, 
	108, 108, 101, 101, 93, 
	93, 111, 111, 100, 100, 
	121, 121, 93, 93, 101, 101, 
	97, 97, 100, 100, 93, 
	93, 93, 93, 98, 114, 
	111, 111, 100, 100, 121, 121, 
	93, 93, 93, 93, 101, 
	101, 97, 97, 100, 100, 
	93, 93, 93, 93, 0, 104, 
	10, 10, 99, 116, 49, 
	54, 9, 126, 32, 126, 
	0, 123, 10, 13, 10, 13, 
	34, 34, 33, 126, 33, 
	126, 33, 126, 33, 126, 
	47, 117, 114, 114, 48, 57, 
	111, 111, 48, 57, 111, 
	111, 48, 57, 116, 116, 
	33, 126, 115, 115, 48, 57, 
	105, 111, 47, 57, 48, 
	57, 48, 57, 48, 57, 
	111, 111, 47, 57, 48, 57, 
	115, 115, 48, 57, 123, 
	123, 0, 91, 47, 47, 
	0, 91, 47, 47, 0, 91, 
	47, 116, 0
]

class << self
	attr_accessor :_dtext_key_spans
	private :_dtext_key_spans, :_dtext_key_spans=
end
self._dtext_key_spans = [
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 33, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 118, 1, 1, 
	14, 1, 1, 1, 1, 58, 1, 1, 
	94, 94, 1, 1, 1, 1, 58, 1, 
	1, 94, 1, 20, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 20, 1, 1, 1, 1, 1, 1, 
	11, 1, 1, 1, 32, 32, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 20, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 10, 1, 
	1, 1, 1, 1, 1, 1, 10, 1, 
	1, 1, 1, 1, 10, 1, 1, 58, 
	1, 1, 94, 1, 1, 1, 1, 1, 
	1, 10, 1, 1, 1, 1, 1, 10, 
	1, 10, 5, 1, 1, 1, 10, 1, 
	1, 1, 10, 1, 1, 1, 1, 1, 
	10, 1, 10, 1, 1, 1, 1, 10, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 18, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 17, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 105, 1, 18, 6, 118, 95, 
	124, 4, 4, 1, 94, 94, 94, 94, 
	71, 1, 10, 1, 10, 1, 10, 1, 
	94, 1, 10, 7, 11, 10, 10, 10, 
	1, 11, 10, 1, 10, 1, 92, 1, 
	92, 1, 92, 70
]

class << self
	attr_accessor :_dtext_index_offsets
	private :_dtext_index_offsets, :_dtext_index_offsets=
end
self._dtext_index_offsets = [
	0, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 52, 54, 56, 58, 60, 62, 
	64, 66, 68, 70, 72, 74, 76, 78, 
	80, 82, 84, 86, 88, 90, 92, 94, 
	96, 98, 100, 102, 104, 106, 225, 227, 
	229, 244, 246, 248, 250, 252, 311, 313, 
	315, 410, 505, 507, 509, 511, 513, 572, 
	574, 576, 671, 673, 694, 696, 698, 700, 
	702, 704, 706, 708, 710, 712, 714, 716, 
	718, 720, 741, 743, 745, 747, 749, 751, 
	753, 765, 767, 769, 771, 804, 837, 839, 
	841, 843, 845, 847, 849, 851, 853, 855, 
	857, 859, 861, 863, 865, 867, 869, 871, 
	873, 875, 877, 879, 881, 883, 885, 906, 
	908, 910, 912, 914, 916, 918, 920, 922, 
	924, 926, 928, 930, 932, 934, 936, 947, 
	949, 951, 953, 955, 957, 959, 961, 972, 
	974, 976, 978, 980, 982, 993, 995, 997, 
	1056, 1058, 1060, 1155, 1157, 1159, 1161, 1163, 
	1165, 1167, 1178, 1180, 1182, 1184, 1186, 1188, 
	1199, 1201, 1212, 1218, 1220, 1222, 1224, 1235, 
	1237, 1239, 1241, 1252, 1254, 1256, 1258, 1260, 
	1262, 1273, 1275, 1286, 1288, 1290, 1292, 1294, 
	1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 
	1321, 1323, 1325, 1327, 1329, 1331, 1333, 1335, 
	1337, 1339, 1358, 1360, 1362, 1364, 1366, 1368, 
	1370, 1372, 1374, 1376, 1378, 1380, 1382, 1384, 
	1402, 1404, 1406, 1408, 1410, 1412, 1414, 1416, 
	1418, 1420, 1422, 1528, 1530, 1549, 1556, 1675, 
	1771, 1896, 1901, 1906, 1908, 2003, 2098, 2193, 
	2288, 2360, 2362, 2373, 2375, 2386, 2388, 2399, 
	2401, 2496, 2498, 2509, 2517, 2529, 2540, 2551, 
	2562, 2564, 2576, 2587, 2589, 2600, 2602, 2695, 
	2697, 2790, 2792, 2885
]

class << self
	attr_accessor :_dtext_indicies
	private :_dtext_indicies, :_dtext_indicies=
end
self._dtext_indicies = [
	1, 0, 2, 0, 3, 0, 4, 0, 
	5, 0, 6, 0, 7, 0, 8, 0, 
	9, 0, 10, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 11, 0, 0, 12, 14, 13, 
	15, 0, 16, 0, 17, 0, 18, 0, 
	19, 0, 20, 0, 21, 0, 22, 0, 
	23, 0, 24, 0, 25, 0, 26, 0, 
	27, 0, 28, 0, 29, 0, 30, 0, 
	31, 0, 32, 0, 33, 0, 34, 0, 
	35, 0, 36, 0, 37, 0, 38, 0, 
	39, 0, 41, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 42, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	40, 46, 45, 47, 44, 48, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 49, 44, 50, 44, 51, 44, 
	52, 44, 53, 44, 54, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 55, 44, 56, 
	44, 57, 44, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 44, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 59, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	44, 54, 44, 60, 44, 61, 44, 62, 
	44, 63, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 64, 44, 65, 44, 66, 44, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 44, 63, 
	44, 68, 44, 44, 69, 44, 44, 44, 
	70, 44, 44, 44, 44, 44, 44, 44, 
	71, 44, 72, 73, 74, 44, 75, 44, 
	76, 44, 77, 44, 78, 44, 79, 44, 
	80, 44, 81, 44, 82, 44, 83, 44, 
	84, 44, 85, 44, 86, 44, 87, 44, 
	88, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 89, 44, 90, 44, 91, 
	44, 92, 44, 93, 44, 94, 44, 95, 
	44, 96, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 97, 44, 98, 44, 99, 
	44, 100, 44, 44, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 44, 101, 103, 102, 102, 102, 
	102, 102, 102, 102, 102, 102, 102, 102, 
	102, 102, 102, 102, 102, 102, 102, 102, 
	102, 102, 102, 102, 102, 102, 102, 102, 
	102, 102, 102, 104, 102, 105, 44, 44, 
	106, 108, 107, 109, 44, 110, 44, 111, 
	44, 112, 44, 113, 44, 114, 44, 115, 
	44, 116, 44, 117, 44, 118, 44, 119, 
	44, 120, 44, 121, 44, 122, 44, 123, 
	44, 124, 44, 125, 44, 126, 44, 127, 
	44, 128, 44, 129, 44, 130, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	131, 44, 132, 44, 133, 44, 134, 44, 
	135, 44, 136, 44, 137, 44, 138, 44, 
	139, 44, 140, 44, 141, 44, 142, 44, 
	143, 44, 144, 44, 145, 44, 146, 44, 
	147, 147, 147, 147, 147, 147, 147, 147, 
	147, 147, 44, 148, 44, 149, 44, 150, 
	44, 151, 44, 152, 44, 153, 44, 154, 
	44, 155, 155, 155, 155, 155, 155, 155, 
	155, 155, 155, 44, 156, 44, 157, 44, 
	158, 44, 159, 44, 160, 44, 161, 161, 
	161, 161, 161, 161, 161, 161, 161, 161, 
	44, 162, 44, 163, 44, 164, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 165, 44, 
	166, 44, 167, 44, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 44, 164, 44, 169, 44, 170, 
	44, 171, 44, 172, 44, 173, 44, 174, 
	174, 174, 174, 174, 174, 174, 174, 174, 
	174, 44, 175, 44, 176, 44, 177, 44, 
	178, 44, 179, 44, 180, 180, 180, 180, 
	180, 180, 180, 180, 180, 180, 44, 182, 
	181, 183, 183, 183, 183, 183, 183, 183, 
	183, 183, 183, 181, 184, 44, 44, 44, 
	185, 44, 186, 44, 187, 44, 188, 44, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 44, 190, 44, 191, 44, 192, 
	44, 193, 193, 193, 193, 193, 193, 193, 
	193, 193, 193, 44, 194, 44, 195, 44, 
	196, 44, 197, 44, 198, 44, 199, 199, 
	199, 199, 199, 199, 199, 199, 199, 199, 
	44, 201, 200, 202, 202, 202, 202, 202, 
	202, 202, 202, 202, 202, 200, 203, 44, 
	204, 44, 205, 44, 206, 44, 207, 207, 
	207, 207, 207, 207, 207, 207, 207, 207, 
	44, 44, 208, 210, 209, 211, 44, 213, 
	212, 214, 212, 215, 212, 216, 212, 217, 
	212, 219, 218, 220, 218, 221, 218, 222, 
	218, 223, 218, 224, 218, 225, 218, 226, 
	218, 228, 227, 229, 230, 227, 227, 227, 
	227, 227, 231, 227, 227, 227, 227, 227, 
	227, 227, 227, 227, 232, 227, 233, 227, 
	234, 227, 235, 227, 236, 227, 237, 227, 
	238, 227, 239, 227, 240, 227, 241, 227, 
	242, 227, 243, 227, 244, 227, 245, 227, 
	246, 227, 247, 227, 227, 227, 248, 227, 
	227, 227, 227, 227, 227, 227, 227, 227, 
	249, 227, 250, 227, 251, 227, 252, 227, 
	253, 227, 254, 227, 255, 227, 256, 227, 
	257, 227, 258, 227, 259, 227, 261, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	262, 260, 260, 263, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 260, 260, 
	260, 264, 260, 260, 260, 260, 260, 260, 
	260, 260, 260, 260, 260, 260, 265, 260, 
	262, 266, 268, 267, 269, 267, 267, 267, 
	267, 267, 267, 267, 267, 270, 267, 267, 
	271, 267, 272, 273, 267, 274, 274, 274, 
	274, 274, 274, 267, 41, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 42, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 275, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 275, 278, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 279, 277, 277, 
	280, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 281, 277, 277, 
	277, 282, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 283, 
	277, 284, 277, 285, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 286, 277, 
	277, 277, 277, 277, 287, 277, 288, 277, 
	277, 289, 277, 290, 291, 277, 277, 277, 
	277, 277, 277, 292, 277, 277, 277, 293, 
	294, 277, 277, 277, 277, 277, 295, 277, 
	297, 296, 296, 297, 296, 297, 298, 298, 
	297, 298, 299, 300, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 301, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 302, 302, 302, 302, 302, 302, 302, 
	302, 299, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 305, 304, 304, 304, 304, 
	305, 306, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	303, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 305, 304, 304, 304, 304, 305, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 304, 
	304, 304, 304, 304, 304, 304, 304, 307, 
	308, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 299, 299, 309, 299, 299, 299, 
	299, 299, 299, 310, 299, 299, 311, 299, 
	299, 299, 312, 299, 299, 299, 299, 313, 
	299, 299, 314, 299, 315, 316, 317, 299, 
	318, 299, 320, 320, 320, 320, 320, 320, 
	320, 320, 320, 320, 319, 321, 299, 323, 
	323, 323, 323, 323, 323, 323, 323, 323, 
	323, 322, 324, 299, 326, 326, 326, 326, 
	326, 326, 326, 326, 326, 326, 325, 327, 
	299, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 328, 
	329, 299, 331, 331, 331, 331, 331, 331, 
	331, 331, 331, 331, 330, 332, 299, 299, 
	299, 299, 299, 333, 299, 335, 336, 336, 
	336, 336, 336, 336, 336, 336, 336, 336, 
	334, 338, 338, 338, 338, 338, 338, 338, 
	338, 338, 338, 337, 340, 340, 340, 340, 
	340, 340, 340, 340, 340, 340, 339, 342, 
	342, 342, 342, 342, 342, 342, 342, 342, 
	342, 341, 343, 299, 345, 346, 346, 346, 
	346, 346, 346, 346, 346, 346, 346, 344, 
	348, 348, 348, 348, 348, 348, 348, 348, 
	348, 348, 347, 349, 299, 351, 351, 351, 
	351, 351, 351, 351, 351, 351, 351, 350, 
	352, 299, 354, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 353, 353, 353, 
	353, 353, 353, 353, 353, 355, 353, 357, 
	356, 359, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 358, 358, 358, 358, 
	358, 358, 358, 358, 360, 358, 362, 361, 
	364, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 363, 363, 363, 363, 363, 
	363, 363, 363, 365, 363, 367, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 366, 366, 366, 366, 366, 366, 
	366, 366, 368, 366, 0
]

class << self
	attr_accessor :_dtext_trans_targs
	private :_dtext_trans_targs, :_dtext_trans_targs=
end
self._dtext_trans_targs = [
	226, 1, 2, 3, 226, 5, 6, 7, 
	8, 9, 10, 226, 11, 11, 226, 13, 
	14, 15, 16, 17, 18, 226, 20, 21, 
	22, 23, 226, 25, 26, 27, 28, 29, 
	30, 226, 32, 33, 34, 35, 226, 37, 
	226, 37, 230, 231, 232, 38, 39, 40, 
	41, 51, 42, 43, 44, 45, 46, 50, 
	47, 48, 49, 232, 52, 53, 54, 55, 
	58, 56, 57, 236, 60, 61, 67, 68, 
	73, 80, 83, 232, 62, 63, 64, 65, 
	66, 232, 232, 69, 70, 71, 72, 232, 
	232, 74, 75, 76, 77, 78, 79, 232, 
	81, 82, 232, 232, 232, 85, 85, 86, 
	87, 232, 88, 88, 89, 232, 232, 92, 
	93, 94, 95, 96, 232, 232, 99, 100, 
	101, 102, 103, 104, 232, 106, 107, 108, 
	109, 232, 232, 111, 112, 113, 114, 115, 
	116, 232, 118, 232, 232, 121, 122, 123, 
	124, 125, 126, 242, 128, 129, 130, 131, 
	132, 133, 134, 244, 136, 137, 138, 139, 
	140, 246, 142, 143, 144, 147, 145, 146, 
	248, 149, 150, 151, 152, 153, 250, 155, 
	156, 157, 158, 159, 252, 232, 161, 253, 
	163, 167, 164, 165, 166, 254, 168, 169, 
	170, 255, 172, 173, 174, 175, 176, 257, 
	232, 178, 258, 180, 181, 182, 183, 260, 
	185, 185, 186, 232, 262, 188, 189, 190, 
	191, 262, 264, 193, 194, 195, 196, 197, 
	198, 199, 264, 266, 201, 202, 206, 210, 
	214, 203, 204, 205, 266, 207, 208, 209, 
	266, 211, 212, 213, 266, 266, 216, 220, 
	221, 225, 217, 218, 219, 266, 266, 222, 
	223, 224, 266, 266, 226, 226, 226, 227, 
	228, 229, 226, 226, 0, 4, 12, 19, 
	24, 31, 36, 226, 231, 232, 232, 233, 
	234, 235, 232, 232, 232, 237, 240, 241, 
	243, 245, 247, 249, 251, 256, 259, 261, 
	232, 233, 232, 232, 38, 232, 238, 232, 
	239, 232, 239, 232, 59, 84, 90, 91, 
	97, 98, 105, 110, 117, 119, 120, 232, 
	242, 127, 232, 244, 135, 232, 246, 141, 
	232, 148, 232, 250, 154, 162, 232, 160, 
	252, 232, 253, 232, 254, 232, 255, 171, 
	232, 177, 257, 232, 258, 179, 232, 260, 
	184, 262, 262, 263, 262, 187, 264, 264, 
	265, 264, 192, 266, 266, 267, 266, 200, 
	215
]

class << self
	attr_accessor :_dtext_trans_actions
	private :_dtext_trans_actions, :_dtext_trans_actions=
end
self._dtext_trans_actions = [
	149, 0, 0, 0, 131, 0, 0, 0, 
	0, 0, 0, 133, 1, 0, 186, 0, 
	0, 0, 0, 0, 0, 135, 0, 0, 
	0, 0, 127, 0, 0, 0, 0, 0, 
	0, 129, 0, 0, 0, 0, 137, 3, 
	151, 0, 226, 5, 79, 0, 3, 0, 
	0, 5, 5, 0, 0, 0, 0, 0, 
	0, 0, 0, 189, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 25, 0, 0, 0, 0, 
	0, 53, 29, 0, 0, 0, 0, 45, 
	33, 0, 0, 0, 0, 0, 0, 49, 
	0, 0, 57, 41, 37, 1, 0, 3, 
	3, 19, 5, 0, 7, 21, 23, 0, 
	0, 0, 0, 0, 51, 27, 0, 0, 
	0, 0, 0, 0, 55, 0, 0, 0, 
	0, 43, 31, 0, 0, 0, 0, 0, 
	0, 47, 0, 39, 35, 0, 0, 0, 
	0, 0, 0, 1, 0, 0, 0, 0, 
	0, 0, 0, 1, 0, 0, 0, 0, 
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 0, 0, 0, 204, 77, 0, 5, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	0, 1, 0, 0, 0, 0, 0, 204, 
	75, 0, 5, 0, 0, 0, 0, 1, 
	1, 0, 3, 17, 91, 0, 0, 0, 
	0, 83, 101, 0, 0, 0, 0, 0, 
	0, 0, 93, 125, 0, 0, 0, 0, 
	0, 0, 0, 0, 117, 0, 0, 0, 
	109, 0, 0, 0, 105, 113, 0, 0, 
	0, 0, 0, 0, 0, 107, 115, 0, 
	0, 0, 103, 111, 143, 139, 141, 0, 
	15, 219, 145, 147, 0, 0, 0, 0, 
	0, 0, 1, 201, 0, 67, 65, 216, 
	0, 15, 59, 61, 63, 9, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 
	81, 213, 71, 73, 1, 198, 1, 180, 
	210, 222, 207, 183, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 171, 
	0, 0, 162, 0, 0, 156, 0, 0, 
	69, 0, 174, 0, 0, 0, 177, 3, 
	15, 195, 0, 165, 0, 153, 0, 0, 
	159, 3, 15, 192, 0, 0, 168, 0, 
	0, 87, 85, 15, 89, 0, 97, 95, 
	15, 99, 0, 121, 119, 15, 123, 0, 
	0
]

class << self
	attr_accessor :_dtext_to_state_actions
	private :_dtext_to_state_actions, :_dtext_to_state_actions=
end
self._dtext_to_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 11, 0, 0, 0, 0, 0, 
	11, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 11, 0, 
	11, 0, 11, 0
]

class << self
	attr_accessor :_dtext_from_state_actions
	private :_dtext_from_state_actions, :_dtext_from_state_actions=
end
self._dtext_from_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 13, 0, 0, 0, 0, 0, 
	13, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 13, 0, 
	13, 0, 13, 0
]

class << self
	attr_accessor :_dtext_eof_trans
	private :_dtext_eof_trans, :_dtext_eof_trans=
end
self._dtext_eof_trans = [
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 41, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	182, 182, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 
	45, 201, 201, 45, 45, 45, 45, 45, 
	45, 45, 45, 213, 213, 213, 213, 213, 
	219, 219, 219, 219, 219, 219, 219, 219, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	228, 228, 0, 267, 268, 268, 276, 276, 
	0, 297, 299, 300, 302, 300, 304, 308, 
	300, 300, 320, 300, 323, 300, 326, 300, 
	329, 300, 331, 300, 335, 338, 340, 342, 
	300, 345, 348, 300, 351, 300, 0, 357, 
	0, 362, 0, 367
]

class << self
	attr_accessor :dtext_start
end
self.dtext_start = 226;
class << self
	attr_accessor :dtext_first_final
end
self.dtext_first_final = 226;
class << self
	attr_accessor :dtext_error
end
self.dtext_error = -1;

class << self
	attr_accessor :dtext_en_inline
end
self.dtext_en_inline = 232;
class << self
	attr_accessor :dtext_en_code
end
self.dtext_en_code = 262;
class << self
	attr_accessor :dtext_en_nodtext
end
self.dtext_en_nodtext = 264;
class << self
	attr_accessor :dtext_en_table
end
self.dtext_en_table = 266;
class << self
	attr_accessor :dtext_en_main
end
self.dtext_en_main = 226;


# line 506 "lexer.rl"
  end

  def h(x)
    CGI.escapeHTML(x)
  end

  def u(x)
    CGI.escape(x)
  end

  def append(string)
    @output << string
  end

  def append_block(string)
    if @flags[:inline]
      @output << " "
    else
      @output << string
    end
  end

  def push_dstack(obj)
    @dstack << obj
  end

  def pop_dstack
    @dstack.pop
  end

  def top_dstack
    @dstack[-1]
  end

  def close_dstack
    while obj = pop_dstack
      case obj
      when :p
        append_block "</p>"

      when :inline_spoiler
        append "</span>"

      when :block_spoiler
        append_block "</p></div>"

      when :block_quote
        append_block "</pre>"

      when :block_expand
        append_block "</div></div>"

      when :block_nodtext
        append_block "</p>"

      when :block_code
        append_block "</pre>"

      when :quote
        append_block "</blockquote>"

      else
        raise SyntaxError.new("Invalid element #{obj}")
      end
    end
  end

  def parse
    
# line 968 "lexer.rb"
begin
	p ||= 0
	pe ||= data.length
	cs = dtext_start
	top = 0
	ts = nil
	te = nil
	act = 0
end

# line 575 "lexer.rl"
    
# line 981 "lexer.rb"
begin # ragel flat
	testEof = false
	_slen, _trans, _keys, _inds, _acts, _nacts = nil
	_goto_level = 0
	_resume = 10
	_eof_trans = 15
	_again = 20
	_test_eof = 30
	_out = 40
	while true
	_trigger_goto = false
	if _goto_level <= 0
	if p == pe
		_goto_level = _test_eof
		next
	end
	end
	if _goto_level <= _resume
	_acts = _dtext_from_state_actions[cs]
	_nacts = _dtext_actions[_acts]
	_acts += 1
	while _nacts > 0
		_nacts -= 1
		_acts += 1
		case _dtext_actions[_acts - 1]
	when 7 then
# line 1 "NONE"
		begin
ts = p
		end
# line 1012 "lexer.rb"
		end # from state action switch
	end
	if _trigger_goto
		next
	end
	_keys = cs << 1
	_inds = _dtext_index_offsets[cs]
	_slen = _dtext_key_spans[cs]
	_wide = data[p].ord
	_trans = if (   _slen > 0 && 
			_dtext_trans_keys[_keys] <= _wide && 
			_wide <= _dtext_trans_keys[_keys + 1] 
		    ) then
			_dtext_indicies[ _inds + _wide - _dtext_trans_keys[_keys] ] 
		 else 
			_dtext_indicies[ _inds + _slen ]
		 end
	end
	if _goto_level <= _eof_trans
	cs = _dtext_trans_targs[_trans]
	if _dtext_trans_actions[_trans] != 0
		_acts = _dtext_trans_actions[_trans]
		_nacts = _dtext_actions[_acts]
		_acts += 1
		while _nacts > 0
			_nacts -= 1
			_acts += 1
			case _dtext_actions[_acts - 1]
	when 0 then
# line 16 "lexer.rl"
		begin

    a1 = p
  		end
	when 1 then
# line 20 "lexer.rl"
		begin

    a2 = p
  		end
	when 2 then
# line 24 "lexer.rl"
		begin

    b1 = p
  		end
	when 3 then
# line 28 "lexer.rl"
		begin

    b2 = p
  		end
	when 4 then
# line 38 "lexer.rl"
		begin
boundary = false		end
	when 5 then
# line 38 "lexer.rl"
		begin
boundary = true		end
	when 8 then
# line 1 "NONE"
		begin
te = p+1
		end
	when 9 then
# line 153 "lexer.rl"
		begin
act = 18;		end
	when 10 then
# line 158 "lexer.rl"
		begin
act = 19;		end
	when 11 then
# line 308 "lexer.rl"
		begin
act = 41;		end
	when 12 then
# line 313 "lexer.rl"
		begin
act = 42;		end
	when 13 then
# line 119 "lexer.rl"
		begin
te = p+1
 begin 
      tags = data[a1...a2]
      append '<a rel="nofollow" href="/posts?tags=' + u(tags) + '">' + h(tags) + '</a>'
     end
		end
	when 14 then
# line 124 "lexer.rl"
		begin
te = p+1
 begin 
      name = data[a1...a2]
      title = name.tr(" ", "_").downcase
      append '<a href="/wiki_pages/show_or_new?title=' + u(title) + '">' + h(name) + '</a>'
     end
		end
	when 15 then
# line 130 "lexer.rl"
		begin
te = p+1
 begin 
      name = data[b1...b2]
      title = data[a1...a2].tr(" ", "_").downcase
      append '<a href="/wiki_pages/show_or_new?title=' + u(title) + '">' + h(name) + '</a>'
     end
		end
	when 16 then
# line 142 "lexer.rl"
		begin
te = p+1
 begin 
      text = data[a1...a2]
      url = data[b1...b2]
      append '<a rel="nofollow" href="' + URI.parse(url).to_s + '">' + text + '</a>'
     end
		end
	when 17 then
# line 158 "lexer.rl"
		begin
te = p+1
 begin 
      name = data[a1...a2]
      if boundary
        marker = data[p]
      else
        marker = ""
      end
      append '<a rel="nofollow" href="/users?name=' + u(name) + '">@' + h(name) + '</a>' + marker
     end
		end
	when 18 then
# line 168 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :b
      append '<strong>'
     end
		end
	when 19 then
# line 173 "lexer.rl"
		begin
te = p+1
 begin 
      raise SyntaxError.new("invalid [/b] tag") unless top_dstack == :b
      pop_dstack
      append "</strong>"
     end
		end
	when 20 then
# line 179 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :i
      append '<em>'
     end
		end
	when 21 then
# line 184 "lexer.rl"
		begin
te = p+1
 begin 
      raise ParseError.new("invalid [/i] tag") unless top_dstack == :i
      pop_dstack
      append "</em>"
     end
		end
	when 22 then
# line 190 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :s
      append "<s>"
     end
		end
	when 23 then
# line 195 "lexer.rl"
		begin
te = p+1
 begin 
      raise ParseError.new("invalid [/s] tag") unless top_dstack == :s
      pop_dstack
      append "</s>"
     end
		end
	when 24 then
# line 201 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :u
      append "<u>"
     end
		end
	when 25 then
# line 206 "lexer.rl"
		begin
te = p+1
 begin 
      raise ParseError.new("invalid [/u] tag") unless top_dstack == :u
      pop_dstack
      append "</u>"
     end
		end
	when 26 then
# line 212 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :tn
      append_block '<p class="tn">'
     end
		end
	when 27 then
# line 217 "lexer.rl"
		begin
te = p+1
 begin 
      raise ParseError.new("invalid [/tn] tag") unless top_dstack == :tn
      pop_dstack
      append_block "</p>"
     end
		end
	when 28 then
# line 225 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :p
        append_block "</p>"
        pop_dstack
      end
      p = p - '[quote]'.size;
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 29 then
# line 234 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :p
        append_block "</p>"
        pop_dstack
      end

      raise ParseError.new("invalid [/quote] tag") unless top_dstack == :quote
      pop_dstack
      append_block "</blockquote>"

      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 30 then
# line 247 "lexer.rl"
		begin
te = p+1
 begin 
      push_dstack :inline_spoiler
      append '<span class="spoiler">'
     end
		end
	when 31 then
# line 252 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :inline_spoiler
        append "</span>"
        pop_dstack
      elsif top_dstack == :block_spoiler
        append_block "</p></div>"
        pop_dstack
        	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

      else
        raise SyntaxError.new("invalid [/spoiler] tag")
      end
     end
		end
	when 32 then
# line 265 "lexer.rl"
		begin
te = p+1
 begin 
      close_dstack
      p = p - '[expand]'.size
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 33 then
# line 271 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :block_expand
        append_block '</div></div>'
        pop_dstack
        	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

      else
        raise SyntaxError.new("invalid [/expand] tag")
      end
     end
		end
	when 34 then
# line 281 "lexer.rl"
		begin
te = p+1
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 264
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 35 then
# line 285 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack != :td
        raise SyntaxError.new("invalid [/td] tag")
      end

      append_block "</td>"
      pop_dstack
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 36 then
# line 296 "lexer.rl"
		begin
te = p+1
 begin 
      append "&amp;"
     end
		end
	when 37 then
# line 300 "lexer.rl"
		begin
te = p+1
 begin 
      append "&lt;"
     end
		end
	when 38 then
# line 304 "lexer.rl"
		begin
te = p+1
 begin 
      append "&gt;"
     end
		end
	when 39 then
# line 318 "lexer.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 40 then
# line 323 "lexer.rl"
		begin
te = p+1
 begin 
      append data[p]
     end
		end
	when 41 then
# line 62 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/posts/' + id + '">post #' + id + '</a>'
     end
		end
	when 42 then
# line 67 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/forum_posts/' + id + '">forum #' + id + '</a>'
     end
		end
	when 43 then
# line 72 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/forum_topics/' + id + '">topic #' + id + '</a>'
     end
		end
	when 44 then
# line 77 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      page = data[b1...b2]
      append '<a href="/forum_topics/' + id + '?page=' + page + '">topic #' + id + '/p' + page + '</a>'
     end
		end
	when 45 then
# line 83 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/comments/' + id + '">comment #' + id + '</a>'
     end
		end
	when 46 then
# line 88 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/pools/' + id + '">pool #' + id + '</a>'
     end
		end
	when 47 then
# line 93 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/users/' + id + '">user #' + id + '</a>'
     end
		end
	when 48 then
# line 98 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="/artists/' + id + '">artist #' + id + '</a>'
     end
		end
	when 49 then
# line 103 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="https://github.com/r888888888/danbooru/issues/' + id + '">issue #' + id + '</a>'
     end
		end
	when 50 then
# line 108 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      append '<a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=' + id + '">pixiv #' + id + '</a>'
     end
		end
	when 51 then
# line 113 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      id = data[a1...a2]
      page = data[b1...b2]
      append '<a href="http://www.pixiv.net/member_illust.php?mode=manga_big&illust_id=' + id + '&page=' + page + '">pixiv #' + id + '/p' + page + '</a>'
     end
		end
	when 52 then
# line 136 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      text = data[a1...a2]
      url = data[b1...b2]
      append '<a rel="nofollow" href="' + URI.parse(url).to_s + '">' + text + '</a>'
     end
		end
	when 53 then
# line 148 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      url = data[ts...te]
      append '<a rel="nofollow" href="' + URI.parse(url).to_s + '">' + url + '</a>'
     end
		end
	when 54 then
# line 158 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      name = data[a1...a2]
      if boundary
        marker = data[p]
      else
        marker = ""
      end
      append '<a rel="nofollow" href="/users?name=' + u(name) + '">@' + h(name) + '</a>' + marker
     end
		end
	when 55 then
# line 313 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      append_block "<br>"
     end
		end
	when 56 then
# line 323 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      append data[p]
     end
		end
	when 57 then
# line 72 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      id = data[a1...a2]
      append '<a href="/forum_topics/' + id + '">topic #' + id + '</a>'
     end
		end
	when 58 then
# line 108 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      id = data[a1...a2]
      append '<a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=' + id + '">pixiv #' + id + '</a>'
     end
		end
	when 59 then
# line 323 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      append data[p]
     end
		end
	when 60 then
# line 1 "NONE"
		begin
	case act
	when 18 then
	begin begin p = ((te))-1; end

      # probably a tag. examples include @.@ and @_@
      append data[ts...te]
    end
	when 19 then
	begin begin p = ((te))-1; end

      name = data[a1...a2]
      if boundary
        marker = data[p]
      else
        marker = ""
      end
      append '<a rel="nofollow" href="/users?name=' + u(name) + '">@' + h(name) + '</a>' + marker
    end
	when 41 then
	begin begin p = ((te))-1; end

      close_dstack
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

    end
	when 42 then
	begin begin p = ((te))-1; end

      append_block "<br>"
    end
end 
			end
	when 61 then
# line 329 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :block_code
        pop_dstack
        append_block "</pre>"
      else
        raise SyntaxError.new("invalid [/code] tag")
      end
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 62 then
# line 339 "lexer.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 63 then
# line 344 "lexer.rl"
		begin
te = p+1
 begin 
      append data[p]
     end
		end
	when 64 then
# line 344 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      append data[p]
     end
		end
	when 65 then
# line 344 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      append data[p]
     end
		end
	when 66 then
# line 354 "lexer.rl"
		begin
te = p+1
 begin 
      if top_dstack == :block_nodtext
        pop_dstack
        append_block "</p>"
      end
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 67 then
# line 362 "lexer.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 68 then
# line 367 "lexer.rl"
		begin
te = p+1
 begin 
      append data[p]
     end
		end
	when 69 then
# line 367 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      append data[p]
     end
		end
	when 70 then
# line 367 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      append data[p]
     end
		end
	when 71 then
# line 373 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "<thead>"
     end
		end
	when 72 then
# line 377 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "</thead>"
     end
		end
	when 73 then
# line 381 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "<tbody>"
     end
		end
	when 74 then
# line 385 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "</tbody>"
     end
		end
	when 75 then
# line 389 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "<tr>"
     end
		end
	when 76 then
# line 393 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "</tr>"
     end
		end
	when 77 then
# line 397 "lexer.rl"
		begin
te = p+1
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 78 then
# line 401 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "</table>"
      	begin
		top -= 1
		cs = stack[top]
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 79 then
# line 406 "lexer.rl"
		begin
te = p+1
 begin 
      raise SyntaxError.new("Invalid table")
     end
		end
	when 80 then
# line 410 "lexer.rl"
		begin
te = p+1
		end
	when 81 then
# line 410 "lexer.rl"
		begin
te = p
p = p - 1;		end
	when 82 then
# line 410 "lexer.rl"
		begin
 begin p = ((te))-1; end
		end
	when 83 then
# line 414 "lexer.rl"
		begin
act = 61;		end
	when 84 then
# line 481 "lexer.rl"
		begin
act = 71;		end
	when 85 then
# line 427 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "<blockquote>" unless flags[:inline]
      push_dstack :quote
      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 86 then
# line 433 "lexer.rl"
		begin
te = p+1
 begin 
      append_block '<div class="spoiler"><p>'
      push_dstack :block_spoiler
      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 87 then
# line 439 "lexer.rl"
		begin
te = p+1
 begin 
      append_block '<pre>'
      push_dstack :block_code
      	begin
		stack[top] = cs
		top+= 1
		cs = 262
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 88 then
# line 445 "lexer.rl"
		begin
te = p+1
 begin 
      append_block '<div class="expandable"><div class="expandable-header">'
      append_block '<input type="button" value="Show" class="expandable-button"/></div>'
      append_block '<div class="expandable-content">'
      push_dstack :expand
      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 89 then
# line 453 "lexer.rl"
		begin
te = p+1
 begin 
      append_block "<p>"
      push_dstack :block_nodtext
      	begin
		stack[top] = cs
		top+= 1
		cs = 264
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 90 then
# line 459 "lexer.rl"
		begin
te = p+1
 begin 
      append_block '<table class="striped">'
      push_dstack :table
      	begin
		stack[top] = cs
		top+= 1
		cs = 266
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 91 then
# line 465 "lexer.rl"
		begin
te = p+1
 begin 
      msg = data[a1...a2]
      append_block '<div class="expandable"><div class="expandable-header">'
      append_block '<span>' + h(msg) + '</span>'
      append_block '<input type="button" value="Show" class="expandable-button"/></div>'
      append_block '<div class="expandable-content">'
      push_dstack :block_expand
      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 92 then
# line 475 "lexer.rl"
		begin
te = p+1
 begin 
      close_dstack
     end
		end
	when 93 then
# line 479 "lexer.rl"
		begin
te = p+1
		end
	when 94 then
# line 481 "lexer.rl"
		begin
te = p+1
 begin 
      p = p - 1;

      if dstack.empty?
        append_block "<p>"
        push_dstack :p
      end

      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 95 then
# line 414 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      if flags[:inline]
        header = "6"
      else
        header = data[a1...a2]
      end

      text = data[b1...b2]
      append_block '<h' + header + '>'
      append h(text)
      append_block '</h' + header + '>'
     end
		end
	when 96 then
# line 479 "lexer.rl"
		begin
te = p
p = p - 1;		end
	when 97 then
# line 481 "lexer.rl"
		begin
te = p
p = p - 1; begin 
      p = p - 1;

      if dstack.empty?
        append_block "<p>"
        push_dstack :p
      end

      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 98 then
# line 481 "lexer.rl"
		begin
 begin p = ((te))-1; end
 begin 
      p = p - 1;

      if dstack.empty?
        append_block "<p>"
        push_dstack :p
      end

      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

     end
		end
	when 99 then
# line 1 "NONE"
		begin
	case act
	when 61 then
	begin begin p = ((te))-1; end

      if flags[:inline]
        header = "6"
      else
        header = data[a1...a2]
      end

      text = data[b1...b2]
      append_block '<h' + header + '>'
      append h(text)
      append_block '</h' + header + '>'
    end
	when 71 then
	begin begin p = ((te))-1; end

      p = p - 1;

      if dstack.empty?
        append_block "<p>"
        push_dstack :p
      end

      	begin
		stack[top] = cs
		top+= 1
		cs = 232
		_trigger_goto = true
		_goto_level = _again
		break
	end

    end
end 
			end
# line 2166 "lexer.rb"
			end # action switch
		end
	end
	if _trigger_goto
		next
	end
	end
	if _goto_level <= _again
	_acts = _dtext_to_state_actions[cs]
	_nacts = _dtext_actions[_acts]
	_acts += 1
	while _nacts > 0
		_nacts -= 1
		_acts += 1
		case _dtext_actions[_acts - 1]
	when 6 then
# line 1 "NONE"
		begin
ts = nil;		end
# line 2186 "lexer.rb"
		end # to state action switch
	end
	if _trigger_goto
		next
	end
	p += 1
	if p != pe
		_goto_level = _resume
		next
	end
	end
	if _goto_level <= _test_eof
	if p == eof
	if _dtext_eof_trans[cs] > 0
		_trans = _dtext_eof_trans[cs] - 1;
		_goto_level = _eof_trans
		next;
	end
	end
	end
	if _goto_level <= _out
		break
	end
	end
	end

# line 576 "lexer.rl"

    @output.string
  end
end

require 'cgi'
require 'uri'

class DText
  MENTION_REGEXP = /(?<=^| )@\S+/
  
  def self.u(string)
    CGI.escape(string)
  end

  def self.h(string)
    CGI.escapeHTML(string)
  end

  def self.strip_blocks(string, tag)
    blocks = string.scan(/\[\/?#{tag}\]|.+?(?=\[\/?#{tag}\]|$)/m)
    n = 0
    stripped = ""
    blocks.each do |block|
      case block
      when "[#{tag}]"
        n += 1

      when "[/#{tag}]"
        n -= 1

      else
        if n == 0
          stripped += block
        end
      end
    end

    stripped.strip
  end

  def self.parse_inline(str, options = {})
    str.gsub!(/&/, "&amp;")
    str.gsub!(/</, "&lt;")
    str.gsub!(/>/, "&gt;")
    str.gsub!(/\n/m, "<br>") unless options[:ignore_newlines]
    str.gsub!(/\[b\](.+?)\[\/b\]/i, '<strong>\1</strong>')
    str.gsub!(/\[i\](.+?)\[\/i\]/i, '<em>\1</em>')
    str.gsub!(/\[s\](.+?)\[\/s\]/i, '<s>\1</s>')
    str.gsub!(/\[u\](.+?)\[\/u\]/i, '<u>\1</u>')
    str.gsub!(/\[tn\](.+?)\[\/tn\]/i, '<p class="tn">\1</p>')

    str = parse_mentions(str)
    str = parse_links(str)
    str = parse_aliased_wiki_links(str)
    str = parse_wiki_links(str)
    str = parse_post_links(str)
    str = parse_id_links(str)
    str
  end

  def self.parse_mentions(str)
    str.gsub!(MENTION_REGEXP) do |name| 
      next name unless name =~ /[a-z0-9]/i

      if name =~ /([:;,.!?\)\]<>])$/
        name.chop!
        ch = $1
      else
        ch = ""
      end

      '<a href="/users?name=' + u(CGI.unescapeHTML(name[1..-1])) + '">' + name + '</a>' + ch
    end
    str
  end

  def self.parse_table_elements(str)
    str = parse_inline(str, :ignore_newlines => true)
    str.gsub!(/\[(\/?(?:tr|td|th|thead|tbody))\]/, '<\1>')
    str
  end

  def self.parse_links(str)
    str.gsub(/("[^"]+":(https?:\/\/|\/)[^\s\r\n<>]+|https?:\/\/[^\s\r\n<>]+|"[^"]+":\[(https?:\/\/|\/)[^\s\r\n<>\]]+\])+/) do |url|
      ch = ""

      if url =~ /^"([^"]+)":\[(.+)\]$/
        text = $1
        url = $2
      else
        if url =~ /^"([^"]+)":(.+)$/
          text = $1
          url = $2
        else
          text = url
        end

        if url =~ /([;,.!?\)\]<>])$/
          url.chop!
          ch = $1
        end
      end

      '<a href="' + url + '">' + text + '</a>' + ch
    end
  end

  def self.parse_aliased_wiki_links(str)
    str.gsub(/\[\[([^\|\]]+)\|([^\]]+)\]\]/m) do
      text = CGI.unescapeHTML($2)
      title = CGI.unescapeHTML($1).tr(" ", "_").downcase
      %{<a href="/wiki_pages/show_or_new?title=#{u(title)}">#{h(text)}</a>}
    end
  end

  def self.parse_wiki_links(str)
    str.gsub(/\[\[([^\]]+)\]\]/) do
      text = CGI.unescapeHTML($1)
      title = text.tr(" ", "_").downcase
      %{<a href="/wiki_pages/show_or_new?title=#{u(title)}">#{h(text)}</a>}
    end
  end

  def self.parse_post_links(str)
    str.gsub(/\{\{([^\}]+)\}\}/) do
      tags = CGI.unescapeHTML($1)
      %{<a rel="nofollow" href="/posts?tags=#{u(tags)}">#{h(tags)}</a>}
    end
  end

  def self.parse_id_links(str)
    str = str.gsub(/\bpost #(\d+)/i, %{<a href="/posts/\\1">post #\\1</a>})
    str = str.gsub(/\bforum #(\d+)/i, %{<a href="/forum_posts/\\1">forum #\\1</a>})
    str = str.gsub(/\btopic #(\d+)(?!\/p\d|\d)/i, %{<a href="/forum_topics/\\1">topic #\\1</a>})
    str = str.gsub(/\btopic #(\d+)\/p(\d+)/i, %{<a href="/forum_topics/\\1?page=\\2">topic #\\1/p\\2</a>})
    str = str.gsub(/\bcomment #(\d+)/i, %{<a href="/comments/\\1">comment #\\1</a>})
    str = str.gsub(/\bpool #(\d+)/i, %{<a href="/pools/\\1">pool #\\1</a>})
    str = str.gsub(/\buser #(\d+)/i, %{<a href="/users/\\1">user #\\1</a>})
    str = str.gsub(/\bartist #(\d+)/i, %{<a href="/artists/\\1">artist #\\1</a>})
    str = str.gsub(/\bissue #(\d+)/i, %{<a href="https://github.com/r888888888/danbooru/issues/\\1">issue #\\1</a>})
    str = str.gsub(/\bpixiv #(\d+)(?!\/p\d|\d)/i, %{<a href="http://www.pixiv.net/member_illust.php?mode=medium&illust_id=\\1">pixiv #\\1</a>})
    str = str.gsub(/\bpixiv #(\d+)\/p(\d+)/i, %{<a href="http://www.pixiv.net/member_illust.php?mode=manga_big&illust_id=\\1&page=\\2">pixiv #\\1/p\\2</a>})
  end

  def self.parse_list(str, options = {})
    html = ""
    current_item = ""
    layout = []
    nest = 0

    str.split(/\n/).each do |line|
      if line =~ /^\s*(\*+) (.+)/
        if nest > 0
          html += "<li>#{current_item}</li>"
        elsif not current_item.strip.empty?
          html += "<p>#{current_item}</p>"
        end

        nest = $1.size
        current_item = parse_inline($2)
      else
        current_item += parse_inline(line)
      end

      if nest > layout.size
        html += "<ul>"
        layout << "ul"
      end

      while nest < layout.size
        elist = layout.pop
        if elist
          html += "</#{elist}>"
        end
      end
    end

    html += "<li>#{current_item}</li>"

    while layout.any?
      elist = layout.pop
      html += "</#{elist}>"
    end

    html
  end

  def self.parse(str, options = {})
    return "" if str.nil?

    # Make sure quote tags are surrounded by newlines

    unless options[:inline]
      str.gsub!(/\s*\[quote\](?!\])\s*/m, "\n\n[quote]\n\n")
      str.gsub!(/\s*\[\/quote\]\s*/m, "\n\n[/quote]\n\n")
      str.gsub!(/\s*\[code\](?!\])/m, "\n\n[code]\n\n")
      str.gsub!(/\[\/code\]\s*/m, "\n\n[/code]\n\n")
      str.gsub!(/\s*\[spoilers?\](?!\])\s*/m, "\n\n[spoiler]\n\n")
      str.gsub!(/\s*\[\/spoilers?\]\s*/m, "\n\n[/spoiler]\n\n")
      str.gsub!(/^(h[1-6]\.\s*.+)$/, "\n\n\\1\n\n")
      str.gsub!(/\s*\[expand(\=[^\]]*)?\](?!\])\s*/m, "\n\n[expand\\1]\n\n")
      str.gsub!(/\s*\[\/expand\]\s*/m, "\n\n[/expand]\n\n")
      str.gsub!(/\s*\[table\](?!\])\s*/m, "\n\n[table]\n\n")
      str.gsub!(/\s*\[\/table\]\s*/m, "\n\n[/table]\n\n")
    end

    str.gsub!(/(?:\r?\n){3,}/, "\n\n")
    str.strip!
    blocks = str.split(/(?:\r?\n){2}/)
    stack = []
    flags = {}

    html = blocks.map do |block|
      case block
      when /\A(h[1-6])\.\s*(.+)\Z/
        tag = $1
        content = $2

        if options[:inline]
          "<h6>" + parse_inline(content, options) + "</h6>"
        else
          "<#{tag}>" + parse_inline(content, options) + "</#{tag}>"
        end

      when /^\s*\*+ /
        parse_list(block, options)

      when "[quote]"
        if options[:inline]
          ""
        else
          stack << "blockquote"
          "<blockquote>"
        end

      when "[/quote]"
        if options[:inline]
          ""
        elsif stack.last == "blockquote"
          stack.pop
          '</blockquote>'
        else
          ""
        end

      when "[spoiler]"
        stack << "spoiler"
        '<div class="spoiler">'

      when "[/spoiler]"
        if stack.last == "spoiler"
          stack.pop
          "</div>"
        else
          ""
        end

      when "[table]"
        stack << "table"
        flags[:table] = true
        '<table class="striped">'

      when "[/table]"
        if stack.last == "table"
          stack.pop
          flags[:table] = false
          "</table>"
        else
          ""
        end

      when /\[code\](?!\])/
        flags[:code] = true
        stack << "pre"
        '<pre>'

      when /\[\/code\](?!\])/
        flags[:code] = false
        if stack.last == "pre"
          stack.pop
          "</pre>"
        else
          ""
        end

      when /\[expand(?:\=([^\]]*))?\](?!\])/
        stack << "expandable"
        expand_html = '<div class="expandable"><div class="expandable-header">'
        expand_html << "<span>#{h($1)}</span>" if $1.present?
        expand_html << '<input type="button" value="Show" class="expandable-button"/></div>'
        expand_html << '<div class="expandable-content">'
        expand_html

      when /\[\/expand\](?!\])/
        if stack.last == "expandable"
          stack.pop
          '</div></div>'
        end

      else
        if flags[:code]
          CGI.escape_html(block) + "\n\n"
        elsif flags[:table]
          parse_table_elements(block)
        else
          '<p>' + parse_inline(block) + '</p>'
        end
      end
    end

    stack.reverse.each do |tag|
      if tag == "blockquote"
        html << "</blockquote>"
      elsif tag == "div"
        html << "</div>"
      elsif tag == "pre"
        html << "</pre>"
      elsif tag == "spoiler"
        html << "</div>"
      elsif tag == "expandable"
        html << "</div></div>"
      elsif tag == "table"
        html << "</table>"
      end
    end

    html.join("")
  end
end


# class DTextRagelTest < Minitest::Test
#   def p(s)
#     DTextRagel.new(s).parse
#   end

#   def pi(s)
#     DTextRagel.new(s, :inline => true).parse
#   end

#   def assert_parse(expected, input)
#     assert_equal(expected, p(input))
#   end

#   def test_mentions
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"/users?name=he%27llo\">@he&#39;llo</a> blah</p>", "alpha @he'llo blah")
#     assert_parse("<p>@.@ @_@</p>", "@.@ @_@")
#   end

#   def test_mention_with_boundary
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"/users?name=he%27llo\">@he&#39;llo</a>: blah</p>", "alpha @he'llo: blah")
#   end

#   def test_url_linking
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"http://google.com/blah/image.gif?zap=blah&hell=mary\">http://google.com/blah/image.gif?zap=blah&hell=mary</a> beta</p>", "alpha http://google.com/blah/image.gif?zap=blah&hell=mary beta")
#   end

#   def test_textile_linking
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"http://google.com?zap=blah&hell=mary\">blah</a> beta</p>", 'alpha "blah":http://google.com?zap=blah&hell=mary beta')
#   end

#   def test_textile_linking_bracketed
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"http://google.com\">blah</a> beta</p>", 'alpha "blah":[http://google.com] beta')
#   end

#   def test_wiki_linking
#     assert_parse("<p>alpha <a href=\"/wiki_pages/show_or_new?title=wiki_page_title\">wiki page title</a> beta</p>", 'alpha [[wiki page title]] beta')
#   end

#   def test_wiki_linking_aliased
#     assert_parse("<p>alpha <a href=\"/wiki_pages/show_or_new?title=wiki_page_title\">shown text</a> beta</p>", 'alpha [[wiki page title|shown text]] beta')
#   end

#   def test_spoiler_wiki_linking
#     assert_parse("<p>alpha <a href=\"/wiki_pages/show_or_new?title=spoiler\">spoiler</a> beta</p>", 'alpha [[spoiler]] beta')
#   end

#   def test_search_linking
#     assert_parse("<p>alpha <a rel=\"nofollow\" href=\"/posts?tags=blah+pah\">blah pah</a> beta</p>", 'alpha {{blah pah}} beta')
#   end

#   def test_post_id_linking
#     assert_parse("<p>alpha <a href=\"/posts/1234\">post #1234</a> beta</p>", 'alpha post #1234 beta')
#   end

#   def test_forum_post_id_linking
#     assert_parse("<p>alpha <a href=\"/forum_posts/1234\">forum #1234</a> beta</p>", 'alpha forum #1234 beta')
#   end

#   def test_forum_topic_id_linking
#     assert_parse("<p>alpha <a href=\"/forum_topics/1234\">topic #1234</a> beta</p>", 'alpha topic #1234 beta')
#   end

#   def test_forum_topic_id_paginated_linking
#     assert_parse("<p>alpha <a href=\"/forum_topics/1234?page=5\">topic #1234/p5</a> beta</p>", 'alpha topic #1234/p5 beta')
#   end

#   def test_headers
#     assert_parse("<h1>blah blah</h1><p>hey</p>", "h1. blah blah\nhey")
#   end

#   def test_quotes
#     assert_parse("<blockquote>hello andy</blockquote><p>blah<br></p><blockquote>bad andy</blockquote>", "[quote]hello andy[/quote]\nblah\n[quote]bad andy[/quote]")
#   end

#   def test_nested_quotes
#     assert_parse("<blockquote>hello <blockquote>blah</blockquote></blockquote>", "[quote]hello [quote]blah[/quote][/quote]")
#   end

#   def test_block_spoilers
#     assert_parse("<div class=\"spoiler\"><p>hello world</p></div>", "[spoiler]hello world[/spoiler]")
#   end

#   def test_inline_spoilers
#     assert_parse("<p>inline text <span class=\"spoiler\">inline spoilers</span> blah</p>", "inline text [spoiler]inline spoilers[/spoiler] blah")
#     assert_parse("<p> <span class=\"spoiler\">inline spoilers</span> blah</p>", " [spoiler]inline spoilers[/spoiler] blah")
#   end

#   def test_nested_spoilers
#     assert_parse("<div class=\"spoiler\"><p>this is <span class=\"spoiler\">a nested</span> spoiler</p></div>", "[spoiler]this is [spoiler]a nested[/spoiler] spoiler[/spoiler]")
#   end

#   def test_unclosed_spoilers
#     assert_parse("<div class=\"spoiler\"><p>hello world</p></div>", "[spoiler]hello world")
#     assert_parse("<div class=\"spoiler\"><p>hello world<br>new text</p></div>", "[spoiler]hello world\nnew text")
#   end

#   def test_paragraph
#     assert_parse("<p>abc</p>", "abc")
#   end

#   def test_newlines
#     assert_parse("<p>a<br>b<br>c</p>", "a\nb\nc")
#     assert_parse("<p>a</p><p>b</p>", "a\n\nb")
#   end

#   def test_entities
#     assert_parse("<p>&lt;3</p>", "<3")
#   end

#   def test_code
#     assert_parse("<pre>for (i=0; i<5; ++i) {\n  printf(1);\n}\n\nexit(1);</pre>", "[code]for (i=0; i<5; ++i) {\n  printf(1);\n}\n\nexit(1);[/code]")
#   end

#   def test_nodtext
#     assert_parse("<p>[spoiler]hello\nworld[/spoiler]</p>", "[nodtext][spoiler]hello\nworld[/spoiler][/nodtext]")
#     assert_parse("<p>alpha [spoiler]ayyyy[/spoiler] beta</p>", "alpha [nodtext][spoiler]ayyyy[/spoiler][/nodtext] beta")
#   end

#   def test_expand
#     assert_parse("<div class=\"expandable\"><div class=\"expandable-header\"><span>blah blah</span><input type=\"button\" value=\"Show\" class=\"expandable-button\"/></div><div class=\"expandable-content\">hello world</div></div>", "[expand=blah blah]hello world[/expand]")
#   end

#   def test_complex_links_1
#     assert_parse("<p><a href=\"/wiki_pages/show_or_new?title=1\">2 3</a> | <a href=\"/wiki_pages/show_or_new?title=4\">5 6</a></p>", "[[1|2 3]] | [[4|5 6]]")
#     assert_parse("<p>Tags <strong>(<a href=\"/wiki_pages/show_or_new?title=howto%3Atag\">Tagging Guidelines</a> | <a href=\"/wiki_pages/show_or_new?title=howto%3Atag_checklist\">Tag Checklist</a> | <a href=\"/wiki_pages/show_or_new?title=tag_groups\">Tag Groups</a>)</strong></p>", "Tags [b]([[howto:tag|Tagging Guidelines]] | [[howto:tag_checklist|Tag Checklist]] | [[Tag Groups]])[/b]")
#   end

#   def test_inline_flag
#     assert_equal("alpha <span class=\"spoiler\">hello</span> jesus", pi("alpha [spoiler]hello[/spoiler]\n\n[quote]jesus[/quote]").strip)
#   end
# end

require 'benchmark'
sample = File.read("wiki.txt")
ragel = DTextRagel.new(sample)
ragel.parse
